二分图匹配
二分图匹配就是左边一堆点的集合和右边一堆点的集合配对
两两匹配叫做完美匹配
用匈牙利算法求解最大匹配 交替着取匹配和非匹配的路径 如果非匹配路径比匹配的多一条就找到了增广路 地位互换一下就多了一条

KM算法
找到最大权匹配
思想：
初始时令A[i]为所有与xi顶点关联的边的最大权，B[j] = 0。如果当前的相等子图没有完备匹配，就按下面的方法修改顶标以使扩大相等子图，直到相等子图具有完备匹配为止。
我们求当前相等子图的完备匹配失败了，是因为对于某个x顶点，我们找不到一条从它出发的交错路。这时我们获得了一棵交错树，它的叶子结点全部是x顶点。
现在我们把交错树中x顶点的顶标全都减小某个值d，y顶点的顶标全都增加同一个值d，那么我们会发现：
1）两端都在交错树中的边<i,j>，A[i] + B[j]的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。
2）两端都不在交错树中的边<i,j>，A[i]和B[j]都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。
3）x端不在交错树中，y端在交错树中的边<i,j>  ，它的B[j]的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。
4）y端在交错树中，x端不在交错树中的边<i,j>，它的A[i]的值有所减小。它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。
5）到最后，x端每个点至少有一条线连着，y端每个点有一条线连着，说明最后补充完的相等子图一定有完备匹配。
（若由二分图中所有满足A[i] + B[j] == w[i][j]的边<i,j>构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。）
现在的问题就是求d值了。为了使A[i] + B[j] >= w[i][j]始终成立，且至少有一条边进入相等子图，d应该等于:min(A[i] + B[j] - w[i][j]（xi在交错树中,yj不在交错树中）。

Kuhn－Munkres算法流程：
（1）初始化可行顶标的值；
（2）用匈牙利算法寻找完备匹配；
（3）若未找到完备匹配则修改可行顶标的值；
（4）重复（2）（3）直到找到相等子图的完备匹配为止。


bool dfs(int u)
{
    visx[u] = true;
    for(int i = 0; i < numh; i++)
    {
        if(visy[i])continue;
        int t = A[u] + B[i] - mapp[u][i];
        if(!t){
            visy[i] = true;
            if(matching[i] == -1 || dfs(matching[i])){
                //matching[u] = i;
                matching[i] = u;
                return true;
            }
        }else sub[i] = min(sub[i], t);
    }
    return false;
}

void km()
{
    for(int i = 0; i < numm; i++){
        memset(sub, inf, sizeof(sub));
        while(1){
            memset(visx, 0, sizeof(visx));
            memset(visy, 0, sizeof(visy));
            //sub = inf;
            if(dfs(i)){
                break;
            }
            int d = inf;
            for(int j = 0; j < numm; j++){
                if(!visy[j]) d = min(d,sub[j]);
            }

            for(int j = 0; j < numm; j++){
                if(visx[j]) A[j] -= d;
            }
            for(int j = 0; j < numh; j++){
                if(visy[j]) B[j] += d;
                else sub[j] -= d;
            }
        }
    }
}
